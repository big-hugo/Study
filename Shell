#!/bin/bash
#/bin/bash为默认解释器  命令->解释器->内核->硬件
Shell脚本
/etc/shells  可查看本机编译器(可安装)
sh/bash或直接执行  *.sh    打开一个subshell去读取,开启子进程,执行完消失
source或.        *.sh     当前shell去读取,不开子进程

位置变量
$1 第一个输入的变量如: *.sh  第一个

自定义变量
a=10  或  a=(10)
echo $a 或 ${a}

系统环境变量
$PWD当前所在目录  $HOME当前用户家目录  $UID当前用户uid  $HOSTNAME主机名
$PATH系统默认编译路径  $SHELL当前编译器  $PS1一级提示符  $PS2二级提示符

预定义变量
$0所在进程或脚本名  $$PID号  $?执行状态(0正常)  $#已加载位置的变量个数  $*所有变量的值    

语法
""界定范围,$起作用  ''界定范围,所有字符不起作用
> 覆盖重定向        >> 追加重定向
``反撇号或$()  将输出结果作为变量值
read  [-p  '提示信息'] [-t  秒数]  变量名        读取输入信息作为变量
stty -echo/echo   关闭/开启输出显示
export  局部变量[=值]   定义全局变量(在其他bash同样有效)
export -n 全局变量      取消全局变量

运算
expr  2 + 3    整数运算工具expr(乘号需要\*或'*')
$[2+3]或$((2+3))     算式替换
$[1+=2]或let 1-=2    自增自减操作
bc 高精度运算工具  scale=n可约束小数位
echo "scale=4;1.1*$A;2.2+1.1" | bc  非交互运算

条件测试
格式:   "表达式" 或 [表达式]

字符串匹配 
[a==a]  [a=!a]  [ -z $a]测试a是否为空  [ ! -z $a]或[ -n $a ]测试a是否不为空

整数比较
-eq等于 -ne不等于 -gt大于 -ge大于等于 -lt小于 -le小于等于

文件状态测试
-e存在 -d目录 -f文件 -r -w -x 权限

逻辑分隔
&&且,前置命令执行成功后执行后置命令   ||或,前置命令失败后执行后置命令

造数工具
seq  1 100制造1~100的数   $RANDOM生成一个随机数   {1..100}生成1~100的数
范围随机=$[RANDOM%范围+1]

返回值
exit * 定义退出脚本的返回值   >&2 把输出变为错误输出
>  收集正确输出   2< 收集错误输出  &>  /dev/null 收集所有输出扔到黑洞

输出颜色
echo -e "\033[32m文本\033[0m"   把输出变为绿色(改变前面*m可改变颜色,后面的0m为恢复)
echo -n 不换行输出

循环语句
continue结束本次循环   break跳出循环体   exit退出脚本
while :或[ 判断 ]     for  变量  in  范围       case  变量  in      if[];then
do                    do                       模式1)  命令;;         命令
    命令                    命令                    ...            elif[];then
done                  done                     *)    默认命令         ...
                                                     esac         else  命令 fi
变量截取
${变量:起始位:长度}       起始位从0开始,截取字符串
${变量/旧/新}            替换第1个字符
${变量//旧/新}           替换所有匹配结果
${变量#*字符}            掐头,删除第1个匹配字符和前面的所有
${变量##*字符}           掐头,删除最后一个匹配字符和前面的所有
${变量%字符*}            去尾,删除第1个匹配字符和后面的所有
${变量%%字符*}           去尾,删除最后一个匹配字符和后面的所有
${变量:-默认值}          如果变量为空值,此处使用默认值

函数
函数名(){命令}
fork炸弹  .(){.|.&};.

cron计划任务
按照设置的时间间隔为用户执行系统任务
计划任务执行日志文件/var/log/cron
crontab -e [-u 用户]     设置计划任务(-l 查看,-r 清除)
分 时 日 月 周    命令(绝对路径)               设置计划任务
1  1  1  * 2    /bin/echo hello             每月周二或1号的1时1分执行                            
* 匹配范围内任意时间             , 分割多个不连续的时间点
- 指定连续的时间范围             /n 指定时间频率,每n

正则表达式
^匹配行首  $匹配行尾  []匹配集合中的任意单个字符  [^]集合取反 [a-z0-9A-Z]
.匹配任意单个字符  *匹配前一个字符任意次数  \{n,m\}匹配前一个字符n到m次的行
\{n\}匹配前一个字符n次的行  \{n,\}匹配前一个字符n次以上的行   \(\)保留
扩展正则表达式
+最少匹配一次  ?最多匹配一次  {n,m}匹配n到m次  ()组合为整体,保留
|或者  \b以数字,字母,下划线为边界  \w匹配数字字母下划线  \d匹配数字
\s匹配空白  \<匹配单子开头  \>匹配单词结束  \S不匹配空白  \W不匹配数字字母下划线

grep过滤工具
egrep 或者 grep -e可以使用正则表达式
grep -v 取反匹配  -i 忽略大小写  ^word 以word开头  word$ 以word结尾  ^$ 空行  {a,min,xy} 匹配集合内容  [a-z] 范围搜索

sed流式编辑器,能逐行操作
用到正则的指令要用''括起
格式
  前置命令 | sed 选项 (定址符)指令 
  sed 选项 (定址符)指令 文档
选项
-n屏蔽默认输出  -r支持扩展正则  -i直接修改源文件  
p输出文档内容  d删除文档内容  s替换  =行号
a行下插入文本  i行上插入文本  c整行替换
例子
sed  -n  /支持正则/p  文档   显示符合条件的行
sed  -n  $=  文档    查看文档行数
sed  s/root/xxx/g   文档    把所有root替换
sed  s/root/xxx/    文档    把每行第一个root替换
sed  -r  's/.//2g'  文档    删除每行第二个字符
sed  's#/bin/bash#/sbin/sh#'  文档  把/bin/bash换为/sbin/sh
sed  -r  's/(^.)(.*)(.$)/\3\2\1/'  文档  替换文本顺序
sed  -r  's/([A-Z])/(\1)/'    文档  大写字母加()
sed  -r  's/#([^#]*$)/*\1/'   文档  最后一个#替换成*
sed  -r  's/([0-9])+( +)(.*)/010-\1 020-\3/'   123 456替换成010-123 020-456

awk数据处理引擎
支持正则和扩展正则
格式:     awk [选项] '[条件][指令]' 文件 
  或     前置命令 | awk [选项] '[条件][指令]'
条件支持
==   !=   >  <  <=  >=  ~匹配  ~!不匹配  &&与  ||或  
+-*%  ++ --  +=  -=  *=  /=
内置变量
NF列数   NR行数   $0整个文档  $1第一列   \t分隔符  \n换行符
选项
-F指定分隔符    FS指定分隔符   -v 变量名=值  定义内置变量
sort对结果进行排序  -n升序   -k指定列排序   -r反转排序
过滤时机
行前处理;逐行处理;行后处理
awk 'BEGIN{print}{print}END{print}'
流程控制
if(){}   
if(){}else{}
if(){}else if{}...
for(i in a){print i,a{i}}    遍历数组,i取下标值
例子
ifconfig eth0 | awk -F[\(\)] '/RX p|TX p/{print $2}'   提取网卡流量
awk 'NR==1{print}'   输出第一行
seq 200 | awk '($0%3==0)&&($0%13==0){i++}END{print i}' 统计200以内能被3和13整除的数
awk '$1~/^..a/'      匹配第一列第三个字符为a









